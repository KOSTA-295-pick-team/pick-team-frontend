name: Deploy React App to EC2  # 이 GitHub Actions 워크플로우의 이름 (Actions 탭에 표시됨)

on:
  push:
    branches:
      - main  # main 브랜치에 push 이벤트가 발생했을 때 워크플로우 실행
      - production # production 브랜치에 push 이벤트가 발생했을 때 워크플로우 실행

jobs:
  deploy:                      # 배포 작업의 고유 ID
    name: Deploy to EC2        # GitHub Actions UI에 표시될 작업 이름
    runs-on: ubuntu-latest     # GitHub Actions가 실행될 가상 머신 (Ubuntu 최신 버전)

    env:
      GITHUB_REF_NAME: ${{ github.ref_name }}     # 이벤트가 일어난 브랜치 이름 읽어오기

    steps:
      - name: 코드 체크아웃
        uses: actions/checkout@v4 # 현재 레포지토리의 코드를 가져옴 (Git clone)

      - name: Node.js 환경 설정
        uses: actions/setup-node@v4  # Node.js 환경 설정
        with:
          node-version: 20   # Node.js 20버전 설치
          cache: 'npm'       # npm 캐시 활용으로 빌드 속도 향상

      - name: 의존성 설치
        run: npm install  # npm ci 대신 npm install 사용으로 유연한 관리

      - name: 브랜치 환경 로그 확인
        run: |
          echo "=== 배포 환경 정보 ==="
          echo "현재 브랜치: ${GITHUB_REF_NAME}"
          echo "커밋 SHA: ${{ github.sha }}"
          echo "실행자: ${{ github.actor }}"
          echo "==========================="

      - name: 환경변수 및 호스트 설정
        run: |
          if [ "${GITHUB_REF_NAME}" == "main" ]; then
            # DEV 환경: 프론트엔드 환경변수 파일 생성 (빌드용)
            echo "${{ secrets.ENV_DEV }}" > .env.production
            
            # Docker 환경변수 파일 생성
            echo "${{ secrets.ENV_DEV }}" > .env
            
            # .env 파일에서 환경변수 읽어서 GitHub ENV에 설정
            source .env
            echo "EC2_HOST=${{ secrets.EC2_HOST_DEV }}" >> $GITHUB_ENV
            echo "DOCKER_FRONT_DIRECTORY=${DOCKER_FRONT_DIRECTORY}" >> $GITHUB_ENV
            echo "DOCKER_NGINX_DIRECTORY=${DOCKER_NGINX_DIRECTORY}" >> $GITHUB_ENV
            echo "DEPLOY_ENV=development" >> $GITHUB_ENV
            echo "개발 환경 설정 완료"
          elif [ "${GITHUB_REF_NAME}" == "production" ]; then
            # PROD 환경: 프론트엔드 환경변수 파일 생성 (빌드용)
            echo "${{ secrets.ENV_PROD }}" > .env.production
            
            # Docker 환경변수 파일 생성
            echo "${{ secrets.ENV_PROD }}" > .env
            
            # .env 파일에서 환경변수 읽어서 GitHub ENV에 설정
            source .env
            echo "EC2_HOST=${{ secrets.EC2_HOST_PROD }}" >> $GITHUB_ENV
            echo "DOCKER_FRONT_DIRECTORY=${DOCKER_FRONT_DIRECTORY}" >> $GITHUB_ENV
            echo "DOCKER_NGINX_DIRECTORY=${DOCKER_NGINX_DIRECTORY}" >> $GITHUB_ENV
            echo "DEPLOY_ENV=production" >> $GITHUB_ENV
            echo "운영 환경 설정 완료"
          else
            echo "지원되지 않는 브랜치입니다: ${GITHUB_REF_NAME}"
            echo "main 또는 production 브랜치만 배포 가능합니다."
            exit 1
          fi

      - name: React 앱 빌드
        run: |
          echo "React 앱 빌드 시작..."
          
          # 빌드 모드 설정
          if [ "${GITHUB_REF_NAME}" == "main" ]; then
            export BUILD_MODE=production
            echo "main 브랜치 -> production 빌드 모드 설정 (추후 배포 브랜치 정책에 따라 변경 예정)"
          elif [ "${GITHUB_REF_NAME}" == "production" ]; then
            export BUILD_MODE=production
            echo "production 브랜치 -> production 빌드 모드 설정"
          fi
          
          echo "빌드 모드: $BUILD_MODE"
          echo "사용할 환경변수 파일: .env.$BUILD_MODE"
          
          # 환경변수 파일 확인
          if [ -f ".env.$BUILD_MODE" ]; then
            echo "환경변수 파일 내용:"
            cat ".env.$BUILD_MODE"
          else
            echo "⚠️ 환경변수 파일을 찾을 수 없습니다: .env.$BUILD_MODE"
          fi
          
          # Vite 빌드 실행 (mode 옵션으로 자동으로 .env.[mode] 파일 로드)
          npm run build -- --mode $BUILD_MODE
          
          # 빌드 결과 검증
          if [ ! -d "./dist" ]; then
            echo "빌드 실패: dist 폴더가 생성되지 않았습니다."
            exit 1
          fi
          
          echo "React 앱 빌드 완료"
          echo "빌드 폴더 크기: $(du -sh ./dist | cut -f1)"

      - name: 배포 필수 파일 검증
        run: |
          echo "배포에 필요한 파일들 검증 중..."
          
          # 필수 파일 목록
          required_files=(
            "./docker-compose.yml"
            "./dist"
            "./Dockerfile"
            "./.env"
            "./ext_nginx"
            "./ext_nginx/docker-compose.yml"
            "./ext_nginx/nginx.conf"
          )
          
          # 각 파일 존재 확인
          for file in "${required_files[@]}"; do
            if [ ! -e "$file" ]; then
              echo "필수 파일이 없습니다: $file"
              exit 1
            else
              echo "$file 확인됨"
            fi
          done
          
          echo "모든 필수 파일 검증 완료"

      # EC2 -> 온프레미스로 환경이 변경되었지만 기존 환경변수를 그대로 재사용하기 위해 환경변수명의 접두어는 유지
      - name: EC2로 프론트엔드 파일 복사
        uses: appleboy/scp-action@v0.1.7  # 배포 서버에 파일을 복사
        with:
          host: ${{ env.EC2_HOST }}         # 배포 서버의 공인 IP 또는 도메인
          username: ${{ secrets.EC2_USERNAME }} # 배포 서버 접속용 사용자명
          key: ${{ secrets.EC2_SSH_KEY }}     # SSH 개인 키
          port: ${{ secrets.EC2_SSH_PORT }}   # SSH 커스텀 포트
          source: "./docker-compose.yml,./dist,./Dockerfile,./nginx,./.env"  # 프론트엔드 관련 파일들
          target: ${{ env.DOCKER_FRONT_DIRECTORY }} # 프론트엔드 배포 디렉토리
          timeout: 300s                       # 타임아웃 설정 (5분)
          command_timeout: 60s                # 개별 명령어 타임아웃

      - name: EC2로 ext_nginx 파일 복사
        uses: appleboy/scp-action@v0.1.7  # ext_nginx 파일을 별도 경로에 복사
        with:
          host: ${{ env.EC2_HOST }}         # 배포 서버의 공인 IP 또는 도메인
          username: ${{ secrets.EC2_USERNAME }} # 배포 서버 접속용 사용자명
          key: ${{ secrets.EC2_SSH_KEY }}     # SSH 개인 키
          port: ${{ secrets.EC2_SSH_PORT }}   # SSH 커스텀 포트
          source: "./ext_nginx,./.env"       # ext_nginx 폴더와 환경변수 파일
          target: ${{ env.DOCKER_NGINX_DIRECTORY }} # nginx 전용 배포 디렉토리
          timeout: 300s                       # 타임아웃 설정 (5분)
          command_timeout: 60s                # 개별 명령어 타임아웃

      - name: 서버 배포 실행
        uses: appleboy/ssh-action@v1.0.3  # 배포 서버에 SSH로 접속하여 명령어 실행
        with:
          host: ${{ env.EC2_HOST }}         # 배포 서버의 IP
          username: ${{ secrets.EC2_USERNAME }} # 로그인 사용자명
          key: ${{ secrets.EC2_SSH_KEY }}       # SSH 개인 키
          port: ${{ secrets.EC2_SSH_PORT }}     # SSH 커스텀 포트
          timeout: 600s                         # SSH 연결 타임아웃 (10분)
          command_timeout: 300s                 # 명령어 실행 타임아웃 (5분)
          script: |                            # 접속 후 실행할 명령어 목록
            set -eu  # 오류 발생 시 스크립트 즉시 중단 (undefined variable도 에러)
            
            # Synology 자주 쓰는 경로까지 PATH 확장
            export PATH="/usr/local/bin:/usr/bin:/bin:/sbin:/usr/sbin:/opt/bin:/opt/sbin:/var/packages/Docker/target/usr/bin:$PATH"
            
            # docker-compose v1 경로 탐지 (없으면 v2 fallback)
            COMPOSE_IS_V2=0
            if command -v docker-compose >/dev/null 2>&1; then
              COMPOSE_V1="$(command -v docker-compose)"
            else
              for p in /var/packages/Docker/target/usr/bin/docker-compose /usr/local/bin/docker-compose /usr/bin/docker-compose /bin/docker-compose; do
                [ -x "$p" ] && COMPOSE_V1="$p" && break
              done
            fi
            if [ -z "${COMPOSE_V1:-}" ]; then
              if command -v docker >/dev/null 2>&1 && docker compose version >/dev/null 2>&1; then
                COMPOSE_IS_V2=1
              else
                echo "❌ docker-compose(v1)/docker compose(v2) 없음"
                exit 1
              fi
            fi
            compose() { if [ "$COMPOSE_IS_V2" -eq 1 ]; then docker compose "$@"; else "$COMPOSE_V1" "$@"; fi; }
            echo "✅ compose 사용: $([ "$COMPOSE_IS_V2" -eq 1 ] && echo 'v2(docker compose)' || echo "v1($COMPOSE_V1)")"
            
            echo "배포 서버에서 배포 시작..."
            echo "배포 환경: ${{ env.DEPLOY_ENV }}"
            echo "배포 시작 시간: $(date '+%Y-%m-%d %H:%M:%S')"
            
            FRONT_DIR="${{ env.DOCKER_FRONT_DIRECTORY }}"
            NGINX_DIR="${{ env.DOCKER_NGINX_DIRECTORY }}"
            
            # 배포 디렉토리로 이동
            cd "$FRONT_DIR" || {
              echo "프론트엔드 디렉토리를 찾을 수 없습니다: $FRONT_DIR"
              exit 1
            }
            
            echo "현재 디렉토리 내용 확인:"
            ls -la
            
            # 기존 컨테이너 정리 (안전한 방식으로 - 백엔드와 동일한 로직)
            echo "기존 프론트엔드 서비스 중지 중..."
            
            # 0) 현재 실행 중인 컨테이너 확인
            if compose -f docker-compose.yml ps -q 2>/dev/null | grep -q .; then
              echo "실행 중인 프론트엔드 컨테이너 발견됨. 중지 시도..."
              compose -f docker-compose.yml ps
              
              # 1) 서비스만 안전하게 중지 (실행 중 아니어도 에러 없이 통과)
              if ! compose -f docker-compose.yml stop; then
                echo "⚠️ 프론트엔드 서비스 중지 실패. 강제 종료 시도..."
                compose -f docker-compose.yml kill || true
              fi
              
              # 2) 컨테이너 제거 (볼륨은 건드리지 않음)
              compose -f docker-compose.yml rm -f || true
            else
              echo "실행 중인 프론트엔드 컨테이너가 없습니다."
            fi
            
            # ext_nginx 컨테이너 중지 (별도 디렉토리에서)
            echo "ext_nginx 서비스 중지 중..."
            if [ -n "$NGINX_DIR" ] && [ -d "$NGINX_DIR/ext_nginx" ]; then
              cd "$NGINX_DIR/ext_nginx"
              echo "ext_nginx 디렉토리에서 컨테이너 중지 중..."
              
              # 0) 현재 실행 중인 ext_nginx 컨테이너 확인
              if compose -f docker-compose.yml ps -q 2>/dev/null | grep -q .; then
                echo "실행 중인 ext_nginx 컨테이너 발견됨. 중지 시도..."
                compose -f docker-compose.yml ps
                
                # 1) ext_nginx 서비스만 안전하게 중지
                if ! compose -f docker-compose.yml stop; then
                  echo "⚠️ ext_nginx 서비스 중지 실패. 강제 종료 시도..."
                  compose -f docker-compose.yml kill || true
                fi
                
                # 2) ext_nginx 컨테이너 제거 (볼륨은 건드리지 않음)
                compose -f docker-compose.yml rm -f || true
              else
                echo "실행 중인 ext_nginx 컨테이너가 없습니다."
              fi
            else
              echo "ext_nginx 디렉토리를 찾을 수 없습니다: $NGINX_DIR/ext_nginx"
            fi
            
            # 프론트엔드 디렉토리로 돌아가기
            cd "$FRONT_DIR"
            
            # 이전 이미지 정리
            echo "사용하지 않는 Docker 이미지 정리 중..."
            docker image prune -f || echo "이미지 정리 중 오류 발생"

            # 새로운 프론트엔드 서비스 빌드 및 시작
            echo "새로운 프론트엔드 서비스 빌드 및 시작 중..."
            compose -f docker-compose.yml up -d --build || {
              echo "프론트엔드 Docker Compose 실행 실패"
              echo "상세 로그 확인:"
              compose -f docker-compose.yml logs --tail=50
              exit 1
            }
            
            # 프론트엔드 헬스체크 (있으면 대기)
            echo "⏳ 프론트엔드 서비스 헬스체크 대기 중..."
            for i in $(seq 1 30); do
              if compose -f docker-compose.yml ps | grep -q "Up"; then
                echo "✅ 프론트엔드 서비스 정상 시작됨"
                break
              fi
              sleep 2
            done
            
            # ext_nginx 서비스 시작 (별도 디렉토리에서)
            echo "ext_nginx 서비스 시작 중..."
            if [ -n "$NGINX_DIR" ] && [ -d "$NGINX_DIR/ext_nginx" ]; then
              cd "$NGINX_DIR/ext_nginx"
              compose -f docker-compose.yml up -d --build || {
                echo "ext_nginx Docker Compose 실행 실패"
                echo "상세 로그 확인:"
                compose -f docker-compose.yml logs --tail=50
                exit 1
              }
              
              # ext_nginx 헬스체크 (있으면 대기)
              echo "⏳ ext_nginx 서비스 헬스체크 대기 중..."
              for i in $(seq 1 30); do
                if compose -f docker-compose.yml ps | grep -q "Up"; then
                  echo "✅ ext_nginx 서비스 정상 시작됨"
                  break
                fi
                sleep 2
              done
            else
              echo "⚠️ ext_nginx 디렉토리를 찾을 수 없어 건너뜁니다: $NGINX_DIR/ext_nginx"
            fi
            
            echo "배포 완료"
            echo "배포 완료 시간: $(date '+%Y-%m-%d %H:%M:%S')"
            
            # 서비스 상태 확인
            echo "=== 서비스 상태 확인 ==="
            echo "프론트엔드 컨테이너 상태:"
            cd "$FRONT_DIR"
            compose -f docker-compose.yml ps
            echo ""
            if [ -n "$NGINX_DIR" ] && [ -d "$NGINX_DIR/ext_nginx" ]; then
              echo "ext_nginx 컨테이너 상태:"
              cd "$NGINX_DIR/ext_nginx"
              compose -f docker-compose.yml ps
            fi
            echo "=========================="
            
            echo "🎉 Deploy done (Stop→Recreate + Health Check)"